
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/jrockway/opinionated-server/server/rpclog.go (35.3%)</option>
				
				<option value="file1">github.com/jrockway/opinionated-server/server/server.go (61.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package server

// This package logs RPC requests to zap.  Obviously go-grpc-middleware/logging/zap does this, but
// not as well.

import (
        "context"
        "encoding/json"
        "errors"
        "io"
        "net/http"
        "path"
        "sync"
        "time"

        "github.com/felixge/httpsnoop"
        oldproto "github.com/golang/protobuf/proto" // nolint
        "github.com/grpc-ecosystem/go-grpc-middleware/logging/zap/ctxzap"
        "github.com/jrockway/opinionated-server/internal/formatters"
        jaegerzap "github.com/uber/jaeger-client-go/log/zap"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
        "google.golang.org/grpc"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/encoding/protojson"
        "google.golang.org/protobuf/proto"
)

type pbw struct {
        msg proto.Message
}

func Proto(key string, value interface{}) zap.Field <span class="cov0" title="0">{
        switch msg := value.(type) </span>{
        case zapcore.ObjectMarshaler:<span class="cov0" title="0">
                return zap.Object(key, msg)</span>
        case oldproto.Message:<span class="cov0" title="0">
                return zap.Any(key, &amp;pbw{oldproto.MessageV2(msg)})</span>
        case proto.Message:<span class="cov0" title="0">
                return zap.Any(key, &amp;pbw{msg})</span>
        default:<span class="cov0" title="0">
                return zap.Any(key, value)</span>
        }
}

// MarshalLogObject implements json.Marshaler.
func (p *pbw) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        if p == nil || p.msg == nil </span><span class="cov0" title="0">{
                return []byte("{}"), nil
        }</span>
        <span class="cov0" title="0">return json.RawMessage([]byte(protojson.Format(p.msg))), nil</span>
}

func shouldLog(method string) bool <span class="cov0" title="0">{
        return !suppressInstrumentation(method)
}</span>

func loggerFor(ctx context.Context, fullMethod string) (context.Context, *zap.Logger) <span class="cov0" title="0">{
        service := path.Dir(fullMethod)
        method := path.Base(fullMethod)

        var commonFields []zap.Field
        commonFields = append(commonFields, zap.String("grpc.service", service), zap.String("grpc.method", method), jaegerzap.Trace(ctx))
        if d, ok := ctx.Deadline(); ok </span><span class="cov0" title="0">{
                commonFields = append(commonFields, zap.Time("grpc.deadline", d))
        }</span>
        <span class="cov0" title="0">l := zap.L().Named(method).With(commonFields...)
        return ctxzap.ToContext(ctx, l), l</span>
}

func logStart(ctx context.Context, l *zap.Logger, method string, req interface{}) <span class="cov0" title="0">{
        if !shouldLog(method) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">var reqFields []zap.Field
        if md, ok := metadata.FromIncomingContext(ctx); ok &amp;&amp; logOpts.LogMetadata </span><span class="cov0" title="0">{
                reqFields = append(reqFields, zap.Array("grpc.metadata", &amp;formatters.MetadataWrapper{MD: md}))
        }</span>
        <span class="cov0" title="0">if logOpts.LogPayloads &amp;&amp; req != nil </span><span class="cov0" title="0">{
                reqFields = append(reqFields, Proto("grpc.request", req))
        }</span>
        <span class="cov0" title="0">l.With(reqFields...).Debug("incoming grpc call")</span>
}

func logEnd(ctx context.Context, method string, start time.Time, trailers metadata.MD, res interface{}, err error) <span class="cov0" title="0">{
        fields := []zap.Field{
                zap.Error(err),
                zap.String("grpc.code", status.Code(err).String()),
                zap.Duration("grpc.duration", time.Since(start)),
        }
        if logOpts.LogMetadata &amp;&amp; trailers != nil </span><span class="cov0" title="0">{
                fields = append(fields, zap.Array("grpc.trailers", &amp;formatters.MetadataWrapper{MD: trailers}))
        }</span>
        <span class="cov0" title="0">if logOpts.LogPayloads &amp;&amp; res != nil </span><span class="cov0" title="0">{
                fields = append(fields, Proto("grpc.response", res))
        }</span>
        <span class="cov0" title="0">resLogger := ctxzap.Extract(ctx).With(fields...)
        if err != nil </span><span class="cov0" title="0">{
                // Skip stacktrace here, since it's just to this point and not to the RPC that blew
                // up.
                if ce := resLogger.Check(zap.ErrorLevel, "incoming grpc call finished with error"); ce != nil </span><span class="cov0" title="0">{
                        ce.Entry.Stack = ""
                        ce.Write()
                }</span>
        } else<span class="cov0" title="0"> if shouldLog(method) </span><span class="cov0" title="0">{
                resLogger.Debug("incoming grpc call finished")
        }</span>
}

func loggingUnaryServerInterceptor() grpc.UnaryServerInterceptor <span class="cov6" title="6">{
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov0" title="0">{
                ctx, logger := loggerFor(ctx, info.FullMethod)
                logStart(ctx, logger, info.FullMethod, req)
                start := time.Now()
                res, err := handler(ctx, req)

                logEnd(ctx, info.FullMethod, start, nil, res, err)
                return res, err
        }</span>
}

type incomingHTTPState struct {
        sync.Mutex
        code    int
        n       int
        log     bool
        start   time.Time
        headers http.Header
}

func loggingHTTPInterceptor(name string, handler http.Handler) http.Handler <span class="cov10" title="18">{
        return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) </span><span class="cov6" title="6">{
                ctx := req.Context()
                logger := zap.L().Named(name).With(
                        jaegerzap.Trace(ctx),
                        zap.String("method", req.Method),
                        zap.String("url", req.URL.String()),
                )

                logctx := ctxzap.ToContext(ctx, logger)
                req = req.WithContext(logctx)

                st := new(incomingHTTPState)
                st.start = time.Now()
                st.log = isNotMonitoring(req)
                st.headers = http.Header{}
                if st.log </span><span class="cov6" title="6">{
                        reqLogger := logger
                        if logOpts.LogMetadata </span><span class="cov6" title="6">{
                                reqLogger = logger.With(zap.Array("request.headers", &amp;formatters.MetadataWrapper{MD: req.Header}))
                        }</span>
                        <span class="cov6" title="6">reqLogger.Debug("incoming http request")
                        w = httpsnoop.Wrap(w, httpsnoop.Hooks{
                                Header: func(next httpsnoop.HeaderFunc) httpsnoop.HeaderFunc </span><span class="cov6" title="6">{
                                        return func() http.Header </span><span class="cov6" title="6">{
                                                headers := next()
                                                st.Lock()
                                                st.headers = headers
                                                st.Unlock()
                                                return headers
                                        }</span>
                                },
                                WriteHeader: func(next httpsnoop.WriteHeaderFunc) httpsnoop.WriteHeaderFunc <span class="cov6" title="6">{
                                        return func(code int) </span><span class="cov6" title="6">{
                                                st.Lock()
                                                st.code = code
                                                st.Unlock()
                                                next(code)
                                        }</span>
                                },
                                Write: func(next httpsnoop.WriteFunc) httpsnoop.WriteFunc <span class="cov6" title="6">{
                                        return func(b []byte) (int, error) </span><span class="cov6" title="6">{
                                                n, err := next(b)
                                                st.Lock()
                                                st.n += n
                                                st.Unlock()
                                                return n, err
                                        }</span>
                                },
                        })
                }

                <span class="cov6" title="6">handler.ServeHTTP(w, req)
                st.Lock()
                defer st.Unlock()
                if st.log </span><span class="cov6" title="6">{
                        fields := []zap.Field{zap.Int("code", st.code), zap.Duration("duration", time.Since(st.start))}
                        if logOpts.LogMetadata </span><span class="cov6" title="6">{
                                fields = append(fields, zap.Array("response.headers", &amp;formatters.MetadataWrapper{MD: st.headers}))
                        }</span>
                        <span class="cov6" title="6">logger.Debug("incoming http request finished", fields...)</span>
                }
        })
}

// wrap the server stream to log send/recv events, capture the trailers, and let the rpc method
// get at the logging context.
type wrappedServerStream struct {
        stream          grpc.ServerStream
        ctx             context.Context
        shouldLog       bool
        l               *zap.Logger
        hMu, tMu        sync.Mutex
        header, trailer metadata.MD
}

// Context implements grpc.ServerStream.
func (w *wrappedServerStream) Context() context.Context <span class="cov0" title="0">{
        return w.ctx
}</span>

// SetHeader implements grpc.ServerStream.
func (w *wrappedServerStream) SetHeader(md metadata.MD) error <span class="cov0" title="0">{
        if w.shouldLog &amp;&amp; logOpts.LogMetadata </span><span class="cov0" title="0">{
                w.hMu.Lock()
                w.header = metadata.Join(w.header, md)
                w.hMu.Unlock()
        }</span>
        <span class="cov0" title="0">return w.stream.SetHeader(md)</span>
}

// SendHeader implements grpc.ServerStream.
func (w *wrappedServerStream) SendHeader(md metadata.MD) error <span class="cov0" title="0">{
        if w.shouldLog &amp;&amp; logOpts.LogMetadata </span><span class="cov0" title="0">{
                w.hMu.Lock()
                w.header = metadata.Join(w.header, md)
                w.l.Debug("incoming grpc call sending headers", zap.Array("grpc.headers", &amp;formatters.MetadataWrapper{MD: w.header.Copy()}))
                w.header = nil
                w.hMu.Unlock()
        }</span>

        <span class="cov0" title="0">return w.stream.SendHeader(md)</span>
}

// SetTrailer implements grpc.ServerStream.
func (w *wrappedServerStream) SetTrailer(md metadata.MD) <span class="cov0" title="0">{
        if w.shouldLog &amp;&amp; logOpts.LogMetadata </span><span class="cov0" title="0">{
                w.tMu.Lock()
                w.trailer = metadata.Join(w.trailer, md)
                w.tMu.Unlock()
        }</span>
        <span class="cov0" title="0">w.stream.SetTrailer(md)</span>
}

// RecvMsg implements grpc.ServerStream.
func (w *wrappedServerStream) RecvMsg(m interface{}) error <span class="cov0" title="0">{
        err := w.stream.RecvMsg(m)
        if w.shouldLog &amp;&amp; logOpts.LogPayloads &amp;&amp; err == nil </span><span class="cov0" title="0">{
                w.l.Debug("incoming grpc call received message", Proto("grpc.incoming_msg", m))
        }</span> else<span class="cov0" title="0"> if w.shouldLog &amp;&amp; err != nil &amp;&amp; !errors.Is(err, io.EOF) </span><span class="cov0" title="0">{
                w.l.Error("incoming grpc receive message failed", zap.Error(err))
        }</span>
        <span class="cov0" title="0">return err</span>
}

// SendMsg implements grpc.ServerStream.
func (w *wrappedServerStream) SendMsg(m interface{}) error <span class="cov0" title="0">{
        if w.shouldLog &amp;&amp; logOpts.LogPayloads </span><span class="cov0" title="0">{
                w.l.Debug("incoming grpc call sent message", Proto("grpc.outgoing_msg", m))
        }</span>
        <span class="cov0" title="0">return w.stream.SendMsg(m)</span>
}

func loggingStreamServerInterceptor() grpc.StreamServerInterceptor <span class="cov6" title="6">{
        return func(srv interface{}, stream grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error </span><span class="cov0" title="0">{
                ctx, logger := loggerFor(stream.Context(), info.FullMethod)
                logStart(ctx, logger, info.FullMethod, nil)

                wrapped := &amp;wrappedServerStream{stream: stream, ctx: ctx, l: logger.WithOptions(zap.AddCallerSkip(1)), shouldLog: shouldLog(info.FullMethod)}
                start := time.Now()
                err := handler(srv, wrapped)
                logEnd(ctx, info.FullMethod, start, wrapped.trailer, nil, err)
                return err
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package server initializes an RPC server app, providing gRPC, HTTP, and debug HTTP servers, Jaeger
// tracing, Zap logging, and Prometheus monitoring.
package server

import (
        "context"
        "fmt"
        "io"
        "net"
        "net/http"
        _ "net/http/pprof" // nolint
        "os"
        "os/signal"
        "strings"
        "syscall"
        "time"

        grpc_zap "github.com/grpc-ecosystem/go-grpc-middleware/logging/zap"
        "github.com/grpc-ecosystem/go-grpc-middleware/logging/zap/ctxzap"
        grpc_prometheus "github.com/grpc-ecosystem/go-grpc-prometheus"
        "github.com/grpc-ecosystem/grpc-opentracing/go/otgrpc"
        "github.com/jessevdk/go-flags"
        "github.com/jrockway/opinionated-server/client"
        "github.com/opentracing-contrib/go-stdlib/nethttp"
        "github.com/opentracing/opentracing-go"
        "github.com/povilasv/prommod"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        jaegercfg "github.com/uber/jaeger-client-go/config"
        jaegerzap "github.com/uber/jaeger-client-go/log/zap"
        "github.com/uber/jaeger-client-go/zipkin"
        jprom "github.com/uber/jaeger-lib/metrics/prometheus"
        "go.uber.org/automaxprocs/maxprocs"
        "go.uber.org/zap"
        "golang.org/x/net/http2"
        "golang.org/x/net/http2/h2c"
        "google.golang.org/grpc"
        channelz "google.golang.org/grpc/channelz/service"
        "google.golang.org/grpc/health"
        "google.golang.org/grpc/health/grpc_health_v1"
        "google.golang.org/grpc/reflection"
)

// Info is provided to an (optional) callback after the server has started.  It is mostly
// useful for tests, but is exposed in case you want to do something after the server has started
// serving.
type Info struct {
        HTTPAddress, DebugAddress, GRPCAddress string
}

// InterceptorContext is some state passed to interceptor creation functions registered with
// AddUnaryInterceptorFn and AddStreamInterceptorFn.
type InterceptorContext struct {
        Tracer opentracing.Tracer // The opentracing tracer to be used to trace requests.
        Logger *zap.Logger        // The Zap logger to be used for trace information.  It will never be nil.
}

var (
        AppName          = "server"
        AppVersion       = "unversioned"
        appVersionMetric = promauto.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "app_version",
                        Help: "The version string that was compiled into this app.",
                },
                []string{"name", "version"},
        )

        flagParser      = flags.NewParser(nil, flags.HelpFlag|flags.PassDoubleDash)
        logOpts         = &amp;logOptions{}
        logLevel        zap.AtomicLevel
        listenOpts      = &amp;listenOptions{}
        restoreLogger   = func() {<span class="cov0" title="0">}</span>
        flushTraces     io.Closer
        httpHandler     http.Handler
        serviceHooks    []func(s *grpc.Server)
        startupCallback func(Info)
        drainHandlers   []func()

        healthServer     = health.NewServer()
        debugSetup       = false
        tracingSetup     = false
        grpcLogInstalled = false

        // Interceptors we'd like to add.  We defer evaluation until starting the server, because
        // things like opentracing.GlobalTracer() will be incorrect until then.
        unaryInterceptorFns = []func(ic *InterceptorContext) grpc.UnaryServerInterceptor{
                func(ic *InterceptorContext) grpc.UnaryServerInterceptor <span class="cov6" title="6">{
                        return otgrpc.OpenTracingServerInterceptor(ic.Tracer, otgrpc.IncludingSpans(shouldTrace))
                }</span>,
                func(ic *InterceptorContext) grpc.UnaryServerInterceptor <span class="cov6" title="6">{
                        return grpc_prometheus.UnaryServerInterceptor
                }</span>,
                func(ic *InterceptorContext) grpc.UnaryServerInterceptor <span class="cov6" title="6">{ return loggingUnaryServerInterceptor() }</span>,
        }
        streamInterceptorFns = []func(ic *InterceptorContext) grpc.StreamServerInterceptor{
                func(ic *InterceptorContext) grpc.StreamServerInterceptor <span class="cov6" title="6">{
                        return otgrpc.OpenTracingStreamServerInterceptor(ic.Tracer, otgrpc.IncludingSpans(shouldTrace))
                }</span>,
                func(ic *InterceptorContext) grpc.StreamServerInterceptor <span class="cov6" title="6">{
                        return grpc_prometheus.StreamServerInterceptor
                }</span>,
                func(ic *InterceptorContext) grpc.StreamServerInterceptor <span class="cov6" title="6">{ return loggingStreamServerInterceptor() }</span>,
        }
)

type logOptions struct {
        LogLevel       string `long:"log_level" description:"zap level to log at" default:"debug" env:"LOG_LEVEL"`
        GRPCVerbosity  int    `long:"grpc_verbosity" description:"verbosity level of grpc logs" default:"0" env:"GRPC_GO_LOG_VERBOSITY_LEVEL"`
        DevelopmentLog bool   `long:"pretty_logs" description:"use the nicer-to-look at development log" env:"PRETTY_LOGS"`

        LogMetadata bool `long:"log_metadata" description:"log headers/metadata for each http or grpc request" env:"LOG_METADATA"`
        LogPayloads bool `long:"log_payloads" description:"log requests and responses for each http or grpc request; if true, payloads are logged to the logger and reported to jaeger" env:"LOG_PAYLOADS"`

        LogTraces bool `long:"log_traces" description:"if true, log verbose Jaeger debugging information (more verbose than JAEGER_REPORTER_LOG_SPANS=1)" env:"LOG_TRACES"`
}

type listenOptions struct {
        HTTPAddress         string        `long:"http_address" description:"address to listen for http requests on" default:"0.0.0.0:8080" env:"HTTP_ADDRESS"`
        DebugAddress        string        `long:"debug_address" description:"address to listen for debug http requests on" default:"127.0.0.1:8081" env:"DEBUG_ADDRESS"`
        GRPCAddress         string        `long:"grpc_address" description:"address to listen for grpc requests on" default:"0.0.0.0:9000" env:"GRPC_ADDRESS"`
        PreDrainGracePeriod time.Duration `long:"predrain_grace_period" description:"how long to wait after receiving an exit signal before draining; used to work around long 'network reprogramming' latency" default:"1s" env:"PREDRAIN_GRACE_PERIOD"`
        ShutdownGracePeriod time.Duration `long:"shutdown_grace_period" description:"how long to wait on draining connections before exiting" default:"30s" env:"SHUTDOWN_GRACE_PERIOD"`
}

// AddFlagGroup lets you add your own flags to be parsed with the server-level flags.
func AddFlagGroup(name string, data interface{}) <span class="cov0" title="0">{
        _, err := flagParser.AddGroup(name, "", data)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("add flag group %q: %v", name, err))</span>
        }
}

// Setup sets up the necessary global configuration for your server app.  It parses
// flags/environment variables, and initializes logging, tracing, etc.
//
// If there is a problem, we kill the program.
func Setup() <span class="cov0" title="0">{
        if _, err := flagParser.AddGroup("Addresses", "", listenOpts); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">if _, err := flagParser.AddGroup("Logging", "", logOpts); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">if _, err := flagParser.Parse(); err != nil </span><span class="cov0" title="0">{
                if ferr, ok := err.(*flags.Error); ok &amp;&amp; ferr.Type == flags.ErrHelp </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "%s version %s\n", AppName, AppVersion)
                        fmt.Fprintf(os.Stderr, ferr.Message)
                        os.Exit(2)
                }</span>
                <span class="cov0" title="0">fmt.Fprintf(os.Stderr, "flag parsing: %v\n", err)
                os.Exit(3)</span>
        }

        <span class="cov0" title="0">if err := setup(); err != nil </span><span class="cov0" title="0">{
                zap.L().Fatal("error initializing app", zap.Error(err))
        }</span>
        <span class="cov0" title="0">appVersionMetric.WithLabelValues(AppName, AppVersion).Set(1)
        prometheus.Register(prommod.NewCollector(AppName))
        zap.L().Info("app starting", zap.String("name", AppName), zap.String("version", AppVersion))</span>
}

func maxprocsLogger() maxprocs.Option <span class="cov6" title="6">{
        l := zap.L().Named("maxprocs").WithOptions(zap.AddCallerSkip(1)).Sugar()
        return maxprocs.Logger(func(msg string, args ...interface{}) </span><span class="cov6" title="6">{
                l.Infof(msg, args...)
        }</span>)
}

func setup() error <span class="cov6" title="6">{
        if listenOpts.ShutdownGracePeriod == 0 </span><span class="cov1" title="1">{
                listenOpts.ShutdownGracePeriod = time.Second
        }</span>
        <span class="cov6" title="6">if err := setupLogging(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("setup logging: %w", err)
        }</span>
        <span class="cov6" title="6">if _, err := maxprocs.Set(maxprocsLogger()); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("setup maxprocs: %w", err)
        }</span>
        <span class="cov6" title="6">if err := setupTracing(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("setup tracing: %w", err)
        }</span>
        <span class="cov6" title="6">setupDebug()
        setupClient()
        return nil</span>
}

func setupLogging() error <span class="cov6" title="6">{
        lcfg := zap.NewProductionConfig()
        if logOpts.DevelopmentLog </span><span class="cov0" title="0">{
                lcfg = zap.NewDevelopmentConfig()
        }</span>
        <span class="cov6" title="6">logger, err := lcfg.Build()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("init zap: %w", err)
        }</span>
        <span class="cov6" title="6">restoreLogger = zap.ReplaceGlobals(logger)
        zap.RedirectStdLog(logger)
        logLevel = lcfg.Level
        if err := logLevel.UnmarshalText([]byte(logOpts.LogLevel)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("set log level: %w", err)
        }</span>
        <span class="cov6" title="6">if !grpcLogInstalled </span><span class="cov1" title="1">{
                grpcLogInstalled = true
                grpc_zap.ReplaceGrpcLoggerV2WithVerbosity(zap.L().Named("grpc").WithOptions(zap.AddCallerSkip(2)), logOpts.GRPCVerbosity)
        }</span>
        <span class="cov6" title="6">return nil</span>
}

func setupTracing() error <span class="cov6" title="6">{
        if tracingSetup </span><span class="cov6" title="5">{
                return nil
        }</span>

        <span class="cov1" title="1">jcfg, err := jaegercfg.FromEnv()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("config: %w", err)
        }</span>
        <span class="cov1" title="1">if jcfg.ServiceName == "" </span><span class="cov1" title="1">{
                jcfg.ServiceName = AppName
        }</span>
        <span class="cov1" title="1">zipkinPropagator := zipkin.NewZipkinB3HTTPHeaderPropagator()
        options := []jaegercfg.Option{
                jaegercfg.Logger(jaegerzap.NewLogger(zap.L().Named("jaeger").WithOptions(zap.AddCallerSkip(1)))),
                jaegercfg.Metrics(jprom.New()),
                jaegercfg.Injector(opentracing.HTTPHeaders, zipkinPropagator),
                jaegercfg.Extractor(opentracing.HTTPHeaders, zipkinPropagator),
        }
        tracer, closer, err := jcfg.NewTracer(options...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("tracer: %v", err)
        }</span>
        <span class="cov1" title="1">if logOpts.LogTraces </span><span class="cov0" title="0">{
                tracer = jaegerzap.NewLoggingTracer(zap.L().Named("jaeger_debug"), tracer)
        }</span>
        <span class="cov1" title="1">opentracing.SetGlobalTracer(tracer)
        flushTraces = closer
        tracingSetup = true
        return nil</span>
}

func setupDebug() <span class="cov6" title="6">{
        if debugSetup </span><span class="cov6" title="5">{
                return
        }</span>
        <span class="cov1" title="1">http.Handle("/metrics", promhttp.Handler())
        http.HandleFunc("/zap", func(w http.ResponseWriter, req *http.Request) </span><span class="cov0" title="0">{
                before := logLevel.Level().CapitalString()
                logLevel.ServeHTTP(w, req)
                after := logLevel.Level().CapitalString()
                if before != after </span><span class="cov0" title="0">{
                        ctxzap.Extract(req.Context()).Info("set log level", zap.String("original", before), zap.String("new", after))
                }</span>
        })
        <span class="cov1" title="1">http.HandleFunc("/healthz", func(w http.ResponseWriter, req *http.Request) </span><span class="cov0" title="0">{
                reply, err := healthServer.Check(req.Context(), &amp;grpc_health_v1.HealthCheckRequest{
                        Service: "",
                })
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov0" title="0">status := reply.GetStatus()
                if status != grpc_health_v1.HealthCheckResponse_SERVING </span><span class="cov0" title="0">{
                        http.Error(w, status.String(), http.StatusServiceUnavailable)
                        return
                }</span>
                <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
                w.Write([]byte(status.String()))</span>
        })
        <span class="cov1" title="1">debugSetup = true</span>
}

func setupClient() <span class="cov6" title="6">{
        client.LogMetadata = logOpts.LogMetadata
        client.LogPayloads = logOpts.LogPayloads
        client.ServerSetup = true
}</span>

// AddService registers a gRPC server to be run by the RPC server.  It is intended to be used like:
//
//   server.AddService(func (s *grpc.Server) { my_proto.RegisterMyService(s, myImplementation) })
func AddService(cb func(s *grpc.Server)) <span class="cov0" title="0">{
        serviceHooks = append(serviceHooks, cb)
}</span>

// SetHTTPHandler registers an HTTP handler to serve all non-debug HTTP requests.  You may only
// register a single handler; to serve multiple URLs, use an http.ServeMux.
func SetHTTPHandler(h http.Handler) <span class="cov6" title="6">{
        if httpHandler != nil </span><span class="cov0" title="0">{
                panic("attempt to add an http handler with one already registered")</span>
        }
        <span class="cov6" title="6">httpHandler = h</span>
}

// SetStartupCallback registers a function to be called when the server starts.
func SetStartupCallback(cb func(Info)) <span class="cov6" title="6">{
        if startupCallback != nil </span><span class="cov0" title="0">{
                panic("attempt to add a startup callback with one already registered")</span>
        }
        <span class="cov6" title="6">startupCallback = cb</span>
}

// AddDrainHandler registers a function to be called when the server begins draining.  It is not
// safe to add a drain handler while ListenAndServe is running.
//
// The provided drain handler will be called while your server is still serving, allowing you to
// cleanly interrupt long-lived requests.  If your drain handler blocks, it will interfere with a
// clean shutdown, so don't block.  Your handlers will have the configured grace period to react to
// the drain event.
//
// To cancel select statements, share a channel between the drain handler and your event loop:
//
//         drainCh := make(chan struct{})
//         server.AddDrainHandler(func() { close(drainCh) })
//         ...
//         server.ListenAndServe()
//
// Then in some long-lived handler:
//
//        for {
//                select {
//                case &lt;-drainCh:
//                      return errors.New("draining")
//                case &lt;-ctx.Done():
//                      return ctx.Err()
//                case &lt;-whatever:
//                        // whatever
//                }
//        }
func AddDrainHandler(f func()) <span class="cov0" title="0">{
        drainHandlers = append(drainHandlers, f)
}</span>

// AddUnaryInterceptorFn adds a unary interceptor, computed by f at server startup time, to the server.
func AddUnaryInterceptorFn(f func(ic *InterceptorContext) grpc.UnaryServerInterceptor) <span class="cov0" title="0">{
        unaryInterceptorFns = append(unaryInterceptorFns, f)
}</span>

// AddUnaryInterceptor adds a grpc unary interceptor to the server.
func AddUnaryInterceptor(i grpc.UnaryServerInterceptor) <span class="cov0" title="0">{
        AddUnaryInterceptorFn(func(ic *InterceptorContext) grpc.UnaryServerInterceptor </span><span class="cov0" title="0">{ return i }</span>)
}

// AddStreamInterceptorFn adds a stream interceptor, computed by f at server startup time, to the server.
func AddStreamInterceptorFn(f func(ic *InterceptorContext) grpc.StreamServerInterceptor) <span class="cov0" title="0">{
        streamInterceptorFns = append(streamInterceptorFns, f)
}</span>

// AddStreamInterceptor adds a grpc stream interceptor to the server.
func AddStreamInterceptor(i grpc.StreamServerInterceptor) <span class="cov0" title="0">{
        AddStreamInterceptorFn(func(ic *InterceptorContext) grpc.StreamServerInterceptor </span><span class="cov0" title="0">{ return i }</span>)
}

// isNotMonitoring returns true if the request is not monitoring.  (This is to suppress tracing of
// kubelet health checks and prometheus metric scrapes.)
func isNotMonitoring(req *http.Request) bool <span class="cov6" title="6">{
        if strings.HasPrefix(req.Header.Get("User-Agent"), "kube-probe/") </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov6" title="6">if req.URL != nil &amp;&amp; (req.URL.Path == "/metrics" || req.URL.Path == "/healthz") </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov6" title="6">return true</span>
}

func suppressInstrumentation(method string) bool <span class="cov0" title="0">{
        return strings.HasPrefix(method, "/grpc.health.v1.Health/")
}</span>

func shouldTrace(spanCtx opentracing.SpanContext, method string, req, _ interface{}) bool <span class="cov0" title="0">{
        if spanCtx != nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return !suppressInstrumentation(method)</span>
}

var (
        httpInFlightGauge = promauto.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "http_in_flight",
                        Help: "A gauge of requests currently being served by the wrapped handler.",
                },
                []string{"handler"},
        )

        httpCounter = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "http_requests_total",
                        Help: "A counter for requests to the wrapped handler.",
                },
                []string{"handler", "code", "method"},
        )

        httpDuration = promauto.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "http_request_duration_seconds",
                        Help:    "A histogram of latencies for requests.",
                        Buckets: []float64{0.0005, 0.001, 0.01, 0.1, 0.2, 0.4, 0.8, 1, 1.5, 2, 3, 5, 10, 30, 60, 120, 1200, 3600},
                },
                []string{"handler", "method"},
        )

        httpRequestSize = promauto.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "http_request_size_bytes",
                        Help:    "A histogram of requests sizes for requests.",
                        Buckets: prometheus.ExponentialBuckets(1, 2, 32),
                },
                []string{"handler"},
        )

        httpResponseSize = promauto.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "http_response_size_bytes",
                        Help:    "A histogram of response sizes for requests.",
                        Buckets: prometheus.ExponentialBuckets(1, 2, 32),
                },
                []string{"handler"},
        )
)

func instrumentHandler(name string, handler http.Handler) http.Handler <span class="cov10" title="18">{
        l := prometheus.Labels{"handler": name}
        return promhttp.InstrumentHandlerInFlight(httpInFlightGauge.With(l),
                promhttp.InstrumentHandlerDuration(httpDuration.MustCurryWith(l),
                        promhttp.InstrumentHandlerCounter(httpCounter.MustCurryWith(l),
                                promhttp.InstrumentHandlerRequestSize(httpRequestSize.MustCurryWith(l),
                                        promhttp.InstrumentHandlerResponseSize(httpResponseSize.MustCurryWith(l),
                                                loggingHTTPInterceptor(name, handler),
                                        ),
                                ),
                        ),
                ),
        )
}</span>

// listenAndSereve starts the server and runs until stopped.
func listenAndServe(stopCh chan string) error <span class="cov6" title="6">{
        wantGrpc := len(serviceHooks) &gt; 0

        debugListener, err := net.Listen("tcp", listenOpts.DebugAddress)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("listen on debug port: %w", err)
        }</span>
        <span class="cov6" title="6">defer debugListener.Close()

        var grpcListener net.Listener
        if wantGrpc </span><span class="cov6" title="6">{
                var err error
                if addr := listenOpts.GRPCAddress; strings.HasPrefix(addr, "unix:") </span><span class="cov0" title="0">{
                        grpcListener, err = net.Listen("unix", addr[len("unix:"):])
                }</span> else<span class="cov6" title="6"> {
                        grpcListener, err = net.Listen("tcp", listenOpts.GRPCAddress)
                }</span>
                <span class="cov6" title="6">if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("listen on grpc port: %w", err)
                }</span>
                <span class="cov6" title="6">defer grpcListener.Close()</span>
        }

        <span class="cov6" title="6">var httpListener net.Listener
        if httpHandler != nil </span><span class="cov6" title="6">{
                var err error
                httpListener, err = net.Listen("tcp", listenOpts.HTTPAddress)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("listen on http port: %w", err)
                }</span>
                <span class="cov6" title="6">defer httpListener.Close()</span>
        }

        <span class="cov6" title="6">doneCh := make(chan error)

        debugServer := &amp;http.Server{
                Handler:  h2c.NewHandler(nethttp.Middleware(opentracing.GlobalTracer(), instrumentHandler("debug_http", http.DefaultServeMux), nethttp.MWSpanFilter(isNotMonitoring), nethttp.MWComponentName("debug_http")), &amp;http2.Server{}),
                ErrorLog: zap.NewStdLog(zap.L().Named("debug_http")),
        }

        var httpServer *http.Server
        if httpHandler != nil </span><span class="cov6" title="6">{
                // I'd rather blow up with a null pointer dereference than serve the debug mux on
                // the main port, which is what happens if httpHandler is nil.
                httpServer = &amp;http.Server{
                        Handler:  h2c.NewHandler(nethttp.Middleware(opentracing.GlobalTracer(), instrumentHandler("http", httpHandler), nethttp.MWComponentName("http")), &amp;http2.Server{}),
                        ErrorLog: zap.NewStdLog(zap.L().Named("http")),
                }
        }</span>

        <span class="cov6" title="6">var grpcServer *grpc.Server
        if wantGrpc </span><span class="cov6" title="6">{
                interceptorCtx := &amp;InterceptorContext{
                        Tracer: opentracing.GlobalTracer(),
                        Logger: zap.L(),
                }
                var opts []grpc.ServerOption
                var unaryInterceptors []grpc.UnaryServerInterceptor
                for _, f := range unaryInterceptorFns </span><span class="cov10" title="18">{
                        unaryInterceptors = append(unaryInterceptors, f(interceptorCtx))
                }</span>
                <span class="cov6" title="6">if len(unaryInterceptors) &gt; 0 </span><span class="cov6" title="6">{
                        opts = append(opts, grpc.ChainUnaryInterceptor(unaryInterceptors...))
                }</span>
                <span class="cov6" title="6">var streamInterceptors []grpc.StreamServerInterceptor
                for _, f := range streamInterceptorFns </span><span class="cov10" title="18">{
                        streamInterceptors = append(streamInterceptors, f(interceptorCtx))
                }</span>
                <span class="cov6" title="6">if len(streamInterceptors) &gt; 0 </span><span class="cov6" title="6">{
                        opts = append(opts, grpc.ChainStreamInterceptor(streamInterceptors...))
                }</span>
                <span class="cov6" title="6">grpcServer = grpc.NewServer(opts...)
                grpc_health_v1.RegisterHealthServer(grpcServer, healthServer)
                channelz.RegisterChannelzServiceToServer(grpcServer)
                for _, h := range serviceHooks </span><span class="cov6" title="6">{
                        if h != nil </span><span class="cov6" title="6">{
                                h(grpcServer)
                        }</span>
                }
                <span class="cov6" title="6">reflection.Register(grpcServer)
                defer grpcServer.Stop()</span>
        }

        <span class="cov6" title="6">var servers int
        servers++
        go func() </span><span class="cov6" title="6">{
                zap.L().Info("listening", zap.String("server", "debug"), zap.String("addr", debugListener.Addr().String()))
                if err := debugServer.Serve(debugListener); err != nil </span><span class="cov6" title="6">{
                        doneCh &lt;- fmt.Errorf("debug server: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        doneCh &lt;- nil
                }</span>
        }()
        <span class="cov6" title="6">if grpcServer != nil &amp;&amp; grpcListener != nil </span><span class="cov6" title="6">{
                servers++
                go func() </span><span class="cov6" title="6">{
                        zap.L().Info("listening", zap.String("server", "grpc"), zap.String("addr", grpcListener.Addr().String()))
                        if err := grpcServer.Serve(grpcListener); err != nil </span><span class="cov0" title="0">{
                                doneCh &lt;- fmt.Errorf("grpc server: %v", err)
                        }</span> else<span class="cov6" title="6"> {
                                doneCh &lt;- nil
                        }</span>
                }()
        }
        <span class="cov6" title="6">if httpHandler != nil &amp;&amp; httpListener != nil </span><span class="cov6" title="6">{
                servers++
                go func() </span><span class="cov6" title="6">{
                        zap.L().Info("listening", zap.String("server", "http"), zap.String("addr", httpListener.Addr().String()))
                        if err := httpServer.Serve(httpListener); err != nil </span><span class="cov6" title="6">{
                                doneCh &lt;- fmt.Errorf("http server: %v", err)
                        }</span> else<span class="cov0" title="0"> {
                                doneCh &lt;- nil
                        }</span>
                }()
        }

        <span class="cov6" title="6">if startupCallback != nil </span><span class="cov6" title="6">{
                info := Info{
                        DebugAddress: debugListener.Addr().String(),
                }
                if grpcListener != nil </span><span class="cov6" title="6">{
                        info.GRPCAddress = grpcListener.Addr().String()
                }</span>
                <span class="cov6" title="6">if httpListener != nil </span><span class="cov6" title="6">{
                        info.HTTPAddress = httpListener.Addr().String()
                }</span>
                <span class="cov6" title="6">go startupCallback(info)</span>
        }

        <span class="cov6" title="6">select </span>{
        case reason := &lt;-stopCh:<span class="cov6" title="6">
                zap.L().Info("shutdown requested", zap.String("reason", reason), zap.Int("servers_remaining", servers))</span>
        case doneErr := &lt;-doneCh:<span class="cov0" title="0">
                servers--
                zap.L().Error("server unexpectedly exited", zap.Error(doneErr), zap.Int("servers_remaining", servers))</span>
        }

        <span class="cov6" title="6">zap.L().Info("marking server unhealthy")
        healthServer.Shutdown() // nolint
        if t := listenOpts.PreDrainGracePeriod; t &gt; 0 </span><span class="cov0" title="0">{
                // The idea here is that when we are sent the termination signal, our service
                // controller also removes you from its list of healthy backends, and so we stop
                // receiving new requests.  However, this does not always happen instantly.  This
                // delay allows us to serve normal traffic for a period of time after we have been
                // removed.  Eventually traffic volume will trail off as service discovery stops
                // being able to discover us.  Then we stop accepting connections entirely and allow
                // existing connections to finish (the graceful drain), and finally shut down.
                zap.L().Info("sleeping before drain to wait for network reprogramming", zap.Duration("duration", t))
                time.Sleep(t)
        }</span>

        <span class="cov6" title="6">zap.L().Info("beginning graceful drain", zap.Duration("duration", listenOpts.ShutdownGracePeriod))
        tctx, c := context.WithTimeout(context.Background(), listenOpts.ShutdownGracePeriod)
        defer c()
        for _, h := range drainHandlers </span><span class="cov0" title="0">{
                h()
        }</span>

        <span class="cov6" title="6">go debugServer.Shutdown(tctx) // nolint
        if grpcServer != nil </span><span class="cov6" title="6">{
                go grpcServer.GracefulStop() // nolint
        }</span>
        <span class="cov6" title="6">if httpServer != nil </span><span class="cov6" title="6">{
                go httpServer.Shutdown(tctx) // nolint
        }</span>

        <span class="cov6" title="6">for servers &gt; 0 </span><span class="cov10" title="18">{
                select </span>{
                case &lt;-tctx.Done():<span class="cov0" title="0">
                        zap.L().Error("context expired during graceful drain", zap.Error(err), zap.Int("servers_remaining", servers))
                        return fmt.Errorf("context expired during graceful drain: %w", tctx.Err())</span>
                case err := &lt;-doneCh:<span class="cov10" title="18">
                        servers--
                        zap.L().Info("server exited during graceful drain", zap.Error(err), zap.Int("servers_remaining", servers))</span>
                }
        }
        <span class="cov6" title="6">zap.L().Info("all servers exited")
        return nil</span>
}

var terminationLog = "/dev/termination-log"

// ListenAndServe starts all servers.  SIGTERM or SIGINT will gracefully drain connections.  When
// all servers have exited, this returns.  It is not safe to call ListenAndServe again.
func ListenAndServe() <span class="cov0" title="0">{
        stopCh := make(chan string)
        sigCh := make(chan os.Signal, 1)
        signal.Notify(sigCh, syscall.SIGTERM, syscall.SIGINT)
        go func() </span><span class="cov0" title="0">{
                sig := &lt;-sigCh
                name := sig.String()
                zap.L().Info("got signal", zap.String("signal", name))
                signal.Stop(sigCh)
                stopCh &lt;- name
        }</span>()

        <span class="cov0" title="0">termMsg := []byte("clean shutdown")
        err := listenAndServe(stopCh)
        signal.Stop(sigCh)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Info("server errored", zap.Error(err))
                termMsg = []byte(fmt.Sprintf("error during shutdown: %v", err))
        }</span>

        <span class="cov0" title="0">if err := os.WriteFile(terminationLog, termMsg, 0666); err != nil </span><span class="cov0" title="0">{
                zap.L().Info("failed to write termination log", zap.String("path", terminationLog), zap.Error(err))
        }</span>

        <span class="cov0" title="0">if flushTraces != nil </span><span class="cov0" title="0">{
                flushTraces.Close()
        }</span>
        <span class="cov0" title="0">zap.L().Sync()
        restoreLogger()</span> // This is why we don't allow ListenAndServe to run twice.  It could probably be fixed.
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
